---
layout: post
title:  M202第一周课程笔记
date:   2016-08-16
categories: MongoDB
---

根据[JOOQ](http://www.jooq.org/)对2015年数据库引擎的[分析报告](https://blog.jooq.org/2015/10/15/the-10-most-popular-db-engines-sql-and-nosql-in-2015)，MongoDB已经是最流行的NoSQL数据库。对于移动互联网开发者来说，MongoDB以它的简洁、快速和高效的特性在后台系统数据库选型时已经日益受到开发者的青睐。[MongoDB University](https://university.mongodb.com/)给广大开发者提供了一系列优质的在线培训课程，对小型创业团队来说确实是一件功德无量的事情。

在完成M101系列课程与M102之后，M202将大家带入到关于MongoDB在生产环境中实际应用时的高级运维话题，包括：

- 性能与监控
- 扩展性
- 故障应对
- 问题诊断

对于小型创业团队来说，配备专职的DBA过于奢侈，所以要求后台开发人员既要写好程序，也要做好运维。

## MongoDB的内存模型

在MongoDB版本3.0之前一直使用MMAPv1作为唯一的存储引擎，版本3.0引入WiredTiger（WT）存储引擎供用户选择，版本3.2开始将WT作为MongoDB的默认存储引擎。

### MMAPv1存储引擎

理解MMAPv1的工作机制需要掌握虚拟内存与mmap系统调用的基本概念，基本工作机制是将数据文件按页“惰性加载”（accessed lazily as needed）至物理内存，当物理内存被填满时通过LRU算法进行换页。

### WT存储引擎


### 工作集（Working Set）

MongoDB中工作集包含索引与数据子集（即热数据）两部分。

### 驻留内存（Resident Memory）

驻留内存是对一个进程实际占用内存大小的准确描述，我们可以通过Linux的`top`命令来查看一个进程的驻留内存大小：

![Resident Memory]({{ site.baseurl }}/assets/m202/resident-memory.png)

截图中的`RES`即为进程占用的驻留内存信息。

### 驻留内存与工作集的关系

驻留内存既可能远大于工作集也可能远小于工作集，不能通过查看mongod进程的驻留内存信息来估算工作集的大小。

驻留内存大于工作集的情况课程是这样解释的：

> It is just the difference between how recently and frequently that something has been accessed versus the fact that the process accessed at all, as therefor paged into memory at sometime in the past.

前者（recently and frequently that something has been accessed）是工作集，后者（process accessed at all）是驻留内存。简单来说，驻留内存会包含“冷数据”。

驻留内存小于工作集的情况与journalling有关。首先我们需要了解journaling的工作方式，见下图：

![Journaling]({{ site.baseurl }}/assets/m202/journaling.png)

在完成remap之后，mongod将不再继续拥有原先Shared View（属于驻留内存）的存储空间，这块空间虽然被收归文件系统缓存（FS Cache）所有，但原先已装载的分页依然被保存在这块空间中，如果mongod需重新访问对应数据文件中的部分，文件系统将会快速将这些分页重新划归mongod的驻留内存。

## MongoDB与存储系统

## MongoDB与CPU

## MongoDB与文件系统

## MongoDB与虚拟机与容器
